<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Graph Sequence Analyzer Documentation</title>
    <!-- Add Prism CSS theme (you can choose different themes) -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css"
      rel="stylesheet"
    />
    <!-- Add Prism core CSS -->
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.css"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        line-height: 1.6;
        color: #333;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f8f9fa;
      }
      h1,
      h2,
      h3 {
        color: #2c3e50;
        border-bottom: 2px solid #eee;
        padding-bottom: 10px;
      }
      code {
        background-color: #2d2d2d;
        color: #ccc;
        padding: 2px 4px;
        border-radius: 4px;
        font-family: "Fira Code", "Consolas", monospace;
      }
      pre {
        background-color: #2d2d2d;
        padding: 15px;
        border-radius: 5px;
        overflow-x: auto;
        font-family: "Fira Code", "Consolas", monospace;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .theorem {
        background-color: #e8f4f8;
        border-left: 4px solid #2980b9;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .algorithm {
        background-color: #f8f9f9;
        border-left: 4px solid #27ae60;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .implementation {
        background-color: #fdf5e6;
        border-left: 4px solid #d35400;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .result {
        background-color: #f9ebea;
        border-left: 4px solid #c0392b;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      table {
        border-collapse: collapse;
        width: 100%;
        margin: 20px 0;
        background-color: white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      th,
      td {
        border: 1px solid #ddd;
        padding: 12px;
        text-align: left;
      }
      th {
        background-color: #f5f5f5;
      }
      img {
        max-width: 100%;
        height: auto;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .reference {
        font-size: 0.9em;
        color: #666;
        margin-top: 40px;
        padding: 20px;
        background-color: white;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .note {
        background-color: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .proof {
        background-color: #f0f8ff;
        border-left: 4px solid #4169e1;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .metadata {
        background-color: white;
        padding: 15px;
        border-radius: 5px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .complexity {
        background-color: #e9ecef;
        padding: 15px;
        border-radius: 5px;
        margin: 10px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .example {
        background-color: #f0fff0;
        border-left: 4px solid #98fb98;
        padding: 15px;
        margin: 20px 0;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }
      .math {
        font-family: "Times New Roman", Times, serif;
        font-style: italic;
      }
      /* Code highlighting customization */
      .token.comment,
      .token.prolog,
      .token.doctype,
      .token.cdata {
        color: #8e908c;
      }
      .token.function {
        color: #4271ae;
      }
      .token.keyword {
        color: #8959a8;
      }
      .token.string {
        color: #718c00;
      }
      .token.number {
        color: #f5871f;
      }
      .token.boolean {
        color: #f5871f;
      }
      .token.operator {
        color: #3e999f;
      }
      .token.class-name {
        color: #c82829;
      }
    </style>
  </head>
  <body>
    <div class="metadata">
      <p><strong>Author:</strong> Muhammad Mahdi Amirpour</p>
      <p><strong>Student ID:</strong> 40003033</p>
    </div>

    <h1>Graph Sequence Analyzer Documentation</h1>

    <h2>Table of Contents</h2>
    <ol>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#theoretical">Theoretical Background</a></li>
      <li>
        <a href="#implementation">Implementation Details</a>
        <ul>
          <li><a href="#erdos">Erdős-Gallai Implementation</a></li>
          <li><a href="#havel">Havel-Hakimi Implementation</a></li>
          <li><a href="#graph-gen">Graph Generation</a></li>
        </ul>
      </li>
      <li><a href="#usage">Usage Examples</a></li>
      <li><a href="#complexity">Time and Space Complexity</a></li>
    </ol>

    <h2 id="overview">1. Overview</h2>
    <div class="implementation">
      <p>
        The <code>GraphSequenceAnalyzer</code> class provides a comprehensive
        implementation for analyzing and generating graphs from degree sequences
        using two fundamental theorems:
      </p>
      <ul>
        <li>Erdős-Gallai theorem for sequence verification</li>
        <li>Havel-Hakimi theorem for constructive verification</li>
        <li>Non-isomorphic graph generation algorithm</li>
      </ul>
    </div>

    <h2 id="theoretical">2. Theoretical Background</h2>

    <div class="theorem">
      <h3>Erdős-Gallai Theorem</h3>
      <p>
        A sequence of non-negative integers d₁ ≥ d₂ ≥ ... ≥ dₙ is graphic if and
        only if:
      </p>
      <ol>
        <li>The sum of the sequence is even</li>
        <li>For every k in [1,n]:</li>
      </ol>
      <pre>
sum(dᵢ) ≤ k(k-1) + sum(min(dᵢ,k)) for i=k+1 to n
i=1 to k</pre
      >
    </div>

    <div class="theorem">
      <h3>Havel-Hakimi Theorem</h3>
      <p>A sequence is graphic if and only if the sequence obtained by:</p>
      <ol>
        <li>Removing the largest term d₁</li>
        <li>Subtracting 1 from the next d₁ largest terms</li>
        <li>Reordering in descending order</li>
      </ol>
      <p>is itself graphic (with base case of all zeros being graphic).</p>
    </div>

    <h2 id="implementation">3. Implementation Details</h2>

    <div class="implementation" id="erdos">
      <h3>3.1 Erdős-Gallai Implementation</h3>
      <pre><code class="language-python">
def erdos_gallai_check(self, sequence: List[int]) -> bool:
    """
    Implements the Erdős-Gallai theorem to check if a sequence is graphic.
    
    Args:
        sequence (List[int]): A sequence of non-negative integers
        
    Returns:
        bool: True if the sequence is graphic, False otherwise
    """
    if not sequence:
        return True
        
    # Make a copy and sort in descending order
    seq = sorted(sequence, reverse=True)
    n = len(seq)
    
    # Check if sum is even
    if sum(seq) % 2 != 0:
        return False
        
    # Check Erdős-Gallai conditions
    for k in range(1, n + 1):
        left_sum = sum(seq[:k])
        right_sum = k * (k - 1)
        right_sum += sum(min(seq[i], k) for i in range(k, n))
        
        if left_sum > right_sum:
            return False
            
    return True</code></pre>

      <div class="complexity">
        <strong>Time Complexity:</strong> O(n²)<br />
        <strong>Space Complexity:</strong> O(n)
      </div>
    </div>

    <div class="implementation" id="havel">
      <h3>3.2 Havel-Hakimi Implementation</h3>
      <pre><code class="language-python">
def havel_hakimi_check(self, sequence: List[int]) -> bool:
    """
    Implements the Havel-Hakimi theorem to check if a sequence is graphic.
    
    Args:
        sequence (List[int]): A sequence of non-negative integers
        
    Returns:
        bool: True if the sequence is graphic, False otherwise
    """
    if not sequence:
        return True
    
    # Make a copy to avoid modifying the original sequence
    seq = sequence.copy()
    
    while True:
        # Sort in descending order
        seq.sort(reverse=True)
        
        # If all elements are 0, the sequence is graphic
        if all(x == 0 for x in seq):
            return True
        
        # Get the first element
        d1 = seq.pop(0)
        
        # If d1 is negative or greater than available vertices,
        # the sequence is not graphic
        if d1 < 0 or d1 >= len(seq):
            return False
            
        # Subtract 1 from the next d1 elements
        for i in range(d1):
            if i >= len(seq):
                return False
            seq[i] -= 1</code></pre>

      <div class="complexity">
        <strong>Time Complexity:</strong> O(n²)<br />
        <strong>Space Complexity:</strong> O(n)
      </div>
    </div>

    <div class="implementation" id="graph-gen">
      <h3>3.3 Graph Generation Algorithm</h3>
      <pre><code class="language-python">
    def generate_all_graphs(self, sequence: List[int]) -> List[nx.Graph]:
        """
        Generates all possible non-isomorphic simple graphs with the given degree sequence.
        
        Args:
            sequence (List[int]): A graphic sequence
            
        Returns:
            List[nx.Graph]: List of all non-isomorphic graphs with the given degree sequence
        """
        if not self.is_graphic(sequence):
            return []

        n = len(sequence)
        vertices = list(range(n))
        result_graphs = []
        
        # Generate all possible edge combinations
        potential_edges = list(combinations(vertices, 2))
        
        def is_valid_graph(edges: Set[Tuple[int, int]]) -> bool:
            """Check if a set of edges creates a graph with the desired degree sequence."""
            degrees = [0] * n
            for u, v in edges:
                degrees[u] += 1
                degrees[v] += 1
            return sorted(degrees, reverse=True) == sorted(sequence, reverse=True)

        def generate_graphs(current_edges: Set[Tuple[int, int]], 
                          remaining_edges: List[Tuple[int, int]], 
                          vertex_degrees: List[int]):
            """Recursively generate all possible valid graphs."""
            if is_valid_graph(current_edges):
                G = nx.Graph()
                G.add_nodes_from(vertices)
                G.add_edges_from(current_edges)
                
                # Check if this graph is isomorphic to any existing graph
                if not any(nx.is_isomorphic(G, H) for H in result_graphs):
                    result_graphs.append(G)
                return

            if not remaining_edges:
                return

            edge = remaining_edges[0]
            new_remaining = remaining_edges[1:]
            
            # Try adding the edge
            new_degrees = vertex_degrees.copy()
            new_degrees[edge[0]] += 1
            new_degrees[edge[1]] += 1
            
            if all(d <= s for d, s in zip(new_degrees, sequence)):
                generate_graphs(
                    current_edges | {edge},
                    new_remaining,
                    new_degrees
                )
            
            # Try without adding the edge
            generate_graphs(
                current_edges,
                new_remaining,
                vertex_degrees
            )

        generate_graphs(set(), potential_edges, [0] * n)
        return result_graphs
      </code></pre>

      <div class="complexity">
        <strong>Time Complexity:</strong> O(2^(n choose 2)) worst case<br />
        <strong>Space Complexity:</strong> O(n²) per graph
      </div>
    </div>

    <h2 id="usage">4. Usage Examples</h2>

    <div class="example">
      <h3>Basic Usage</h3>
      <pre><code class="language-python"></code>
        # Create an analyzer instance
        analyzer = GraphSequenceAnalyzer()

        # Test if a sequence is graphic
        sequence = [3, 3, 3, 3]  # K4 (complete graph on 4 vertices)
        is_graphic = analyzer.is_graphic(sequence)

        # Generate all possible graphs
        if is_graphic:
            graphs = analyzer.generate_all_graphs(sequence)
      </code></pre>
    </div>

    <div class="example">
      <h3>Example Sequences</h3>
      <table>
        <tr>
          <th>Sequence</th>
          <th>Description</th>
          <th>Is Graphic</th>
          <th># of Realizations</th>
        </tr>
        <tr>
          <td>[2, 2, 2, 2]</td>
          <td>Cycle on 4 vertices</td>
          <td>Yes</td>
          <td>1</td>
        </tr>
        <tr>
          <td>[3, 3, 3, 3]</td>
          <td>Complete graph K4</td>
          <td>Yes</td>
          <td>1</td>
        </tr>
        <tr>
          <td>[2, 2, 2, 1, 1]</td>
          <td>Path with one branch</td>
          <td>Yes</td>
          <td>3</td>
        </tr>
        <tr>
          <td>[3, 2, 2, 1]</td>
          <td>Star with extra edge</td>
          <td>Yes</td>
          <td>2</td>
        </tr>
      </table>
    </div>

    <h2 id="complexity">5. Time and Space Complexity</h2>

    <div class="result">
      <table>
        <tr>
          <th>Method</th>
          <th>Time Complexity</th>
          <th>Space Complexity</th>
        </tr>
        <tr>
          <td>Erdős-Gallai Check</td>
          <td>O(n²)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Havel-Hakimi Check</td>
          <td>O(n²)</td>
          <td>O(n)</td>
        </tr>
        <tr>
          <td>Graph Generation</td>
          <td>O(2^(n choose 2))</td>
          <td>O(2^n)</td>
        </tr>
        <tr>
          <td>Isomorphism Check</td>
          <td>O(n!)</td>
          <td>O(n²)</td>
        </tr>
      </table>
    </div>

    <div class="reference">
      <h2>References</h2>
      <ol>
        <li>
          Erdős, P., & Gallai, T. (1960). "Graphs with prescribed degrees of
          vertices" (in Hungarian). Matematikai Lapok, 11, 264-274.
        </li>
        <li>
          Havel, V. (1955). "A remark on the existence of finite graphs" (in
          Czech). Časopis pro pěstování matematiky, 80, 477-480.
        </li>
        <li>
          Hakimi, S. L. (1962). "On realizability of a set of integers as
          degrees of the vertices of a linear graph". Journal of SIAM, 10(3),
          496-506.
        </li>
        <li>
          NetworkX Documentation.
          <a href="https://networkx.org/documentation/stable/"
            >https://networkx.org/documentation/stable/</a
          >
        </li>
      </ol>
    </div>
    <!-- Add Prism JS core -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/prism.min.js"></script>
    <!-- Add Python language support -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-python.min.js"></script>
  </body>
</html>
